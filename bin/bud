#!/usr/bin/env ruby

# Use `bud`s Gemfile and bundler dependencies
root = File.expand_path(File.join(__dir__, ".."))
if File.file?(File.join(root, 'Gemfile.lock'))
  Dir.chdir(root) do
    require 'bundler/setup'
  rescue LoadError => e
    warn e.message
    warn "Run `gem install bundler` to install Bundler"
    exit(-1)
  end
end

require "dry/cli"
require "active_support/all"
require "yaml"
require "tty-command"
require "fileutils"
require "bump"
require "pathname"
require "rubygems"
require_relative "support"

DOCKER_PROGRESS = "auto" # auto|plain

module Buddy
  VERSION = "0.0.1"

  module CLI
    module Commands
      extend Dry::CLI::Registry

      class BaseCommand < Dry::CLI::Command
        def run(command)
          result = cmd.run(command)
          halt if result.failed?
          result
        rescue TTY::Command::ExitError => e
          halt
        end

        def halt(message: nil)
          message ||= "#{self.class} failed."
          yell message
          exit
        end

        def parallelize(items, label: nil, &block)
          pids_to_items = {}
          items.each do |item|
            pid = Process.fork do
              begin
                block.call(item)
              rescue SystemExit
                raise
              rescue Exception => e
                warn e.message
                exit 1
              end
            end
            pids_to_items[pid] = item
          end

          failures = []
          pids_to_items.each do |pid, item|
            _wpid, status = Process.wait2(pid)
            failures << item unless status.success?
          end

          halt(message: "#{label || 'Parallel step'} failed for: #{failures.join(', ')}") if failures.any?
        end
      end

      class Version < BaseCommand
        desc "Print version"

        def call(*)
          puts VERSION
        end
      end

      class Bump < BaseCommand
        desc "Bump gem"

        argument :level, desc: "major|minor|patch|pre"
        option :gem, aliases: ["-g"], required: false, desc: "The gem where you want to run the command on"

        def call(level: "minor", gem: nil, **)
          version, _ = ::Bump::Bump.run(level, commit: false, bundle: false, tag: false)

          run("bundle --quiet")

          say message(version)
        end
      end

      class Build < BaseCommand
        desc "Build the gem"

        option :gem, aliases: ["-g"], required: false, desc: "The gem where you want to run the command on"

        def call(gem: nil, forced_avo_version: nil, **)
          FileUtils.mkdir_p "pkg"

          avo_version = forced_avo_version || avo_gem_version

          say "avo version: #{avo_version}"

          remove_previous_gem

          # We prepare these files so the cache does not get busted once the version is incremented in Gemfile.lock
          add_v1_files

          # Build the base image
          run("docker build -t avo_base -f ./../support/docker/Dockerfile.base ./../avo --progress #{DOCKER_PROGRESS}")
          # Build the image with Avo included
          run("docker build -t avo_gems -f ./../support/docker/Dockerfile.gems ./.. --progress #{DOCKER_PROGRESS}")
          say "Base Docker image built"

          # For Avo we use a special Dockerfile and building from the root directory
          dockerfile = (name == "avo") ? "Dockerfile.avo" : "Dockerfile"
          build_path = (name == "avo") ? "../." : "."

          # Build the build image
          say "Building Docker image"
          run("docker build -t #{name} -f ./../support/docker/#{dockerfile} #{build_path} --progress #{DOCKER_PROGRESS} --build-arg NAME=#{name} --build-arg GEMSPEC_NAME=#{gemspec_name} --build-arg BUNDLER_TOKEN=#{bundler_token} --build-arg AVO_VERSION=#{avo_version}")
          say "Docker image built"

          src = "/#{name}/pkg/#{gemspec_name}-#{version}.gem"

          run "docker cp #{image_id}:#{src} #{destination_path}"
          say "Copied gem from docker image to #{destination_path}"

          run("bundle exec appraisal")
        end
      end

      class Push < BaseCommand
        desc "Push the gem"

        option :gem, aliases: ["-g"], required: false, desc: "The gem where you want to run the command on"

        def call(gem: nil, only_push_to_github: false, **)
          say "==============================================="
          say "Pushing #{name}"
          say "==============================================="

          if gemspec_name == "avo" && !only_push_to_github
            `gem push --host https://rubygems.org/ ./pkg/#{gemspec_name}.gem`
          else
            `gem push --key github --host https://rubygems.pkg.github.com/avo-hq ./pkg/#{gemspec_name}.gem`
          end
        end
      end

      class Commit < BaseCommand
        desc "Commit the version change"
        option :gem, aliases: ["-g"], required: false, desc: "The gem where you want to run the command on"

        def call(gem: nil, tag: true, **)
          if name == "avo"
            `git add ./lib/avo/version.rb`
          else
            `git add ./lib/avo/#{name}/version.rb`
          end
          `git add ./Gemfile.lock`

          `git add gemfiles/`

          tag_name = "v#{version}"

          `git commit -m "#{message(version)}"`
          if tag
            `git tag -a -m "#{message(version)}" #{tag_name}`
          end

          `git push origin main --follow-tags`
        end
      end

      class Release < BaseCommand
        desc "Release the gem"

        option :gem, aliases: ["-g"], required: false, desc: "The gem where you want to run the command on"
        option :skip_bump, type: :boolean, aliases: ["-sb"], required: false, desc: "Skip bumping the version."
        argument :level, desc: "major|minor|patch|pre"

        def call(gem: nil, skip_bump: false, level: "patch", **)
          # 1. Bump gem version
          if skip_bump
            # Run bundle to increment the version number in Gemfile.lock
            run("bundle")
          else
            Bump.new.call level:
          end
          # 2. Build the gem
          Build.new.call
          # 3. Push to GitHub packages
          Push.new.call
          # 4. commit & upload tag to git
          #    GitHub action will generate the release with release notes
          Commit.new.call
        end
      end

      class PrepareRelease < BaseCommand
        desc "Prepare release: clean, optional bump, build JS assets"

        argument :level, desc: "major|minor|patch|pre", default: "minor"
        option :skip_bump, type: :boolean, default: false, desc: "Skip bumping the version."

        def call(level: "minor", skip_bump: false, **)
          say "==============================================="
          say "PREPARE RELEASE & BUMP VERSION for #{name}"
          say "==============================================="
          run("rm -rf ./pkg/*")

          if Dir.exist?("app/assets/builds")
            run("rm -rf app/assets/builds/*")
            run("touch app/assets/builds/.keep")
          end

          unless skip_bump
            Bump.new.call level:
          end

          if File.exist?("package.json")
            # run("rm -rf node_modules")
            run("yarn --silent")
            run("yarn build")

            # Avo needs to build the assets again because sym_link requires application.css to be present
            # This is a temporary solution until we have a better way to handle this
            if name == "avo"
              run("rails avo:sym_link")

              if Dir.exist?("app/assets/builds")
                run("rm -rf app/assets/builds/*")
                run("touch app/assets/builds/.keep")
              end

              # run("rm -rf node_modules")
              run("yarn")
              run("yarn build")
            end
          end
        end
      end

      class Encrypt < BaseCommand
        desc "Encrypt gem files using holder's key and loaders"

        option :loader_holder, required: false, default: "avo-licensing", desc: "Loader/holder gem name"

        def call(loader_holder: "avo-licensing", **)
          say "==================================================================="
          say "Encrypting #{name} using #{loader_holder}'s key and loaders"
          say "==================================================================="
          run("evocation encrypt gem #{gemspec_name}.gemspec --key_path ../#{loader_holder}/.evocation/symmetric_key.bin --loader_gem #{loader_holder}")
        end
      end

      class BuildGem < BaseCommand
        desc "Build gem artifacts (rails build)"

        def call(**)
          say "==============================================="
          say "BUILD #{name}"
          say "==============================================="
          run("bundle exec rails build && mv ./pkg/*.gem #{destination_path}")
        end
      end

      class Appraise < BaseCommand
        desc "Run appraisal"

        def call(**)
          say "==============================================="
          say "APPRAISAL for #{name}"
          say "==============================================="
          run("bundle exec appraisal")
        end
      end

      class CleanupEncrypted < BaseCommand
        desc "Remove .enc files and restore originals"

        def call(**)
          say "==============================================="
          say "Removing encrypted files for #{name}"
          say "==============================================="

          run <<~BASH
            for enc_file in $(find . -name "*.enc"); do
              rm -f $enc_file
              git checkout ${enc_file%.enc}.rb
            done
          BASH
        end
      end

      class ReleaseAll < BaseCommand
        # all the gems that will be released
        GEMS = ["avo", "avo-dashboards", "avo-menu", "avo-pro", "avo-dynamic_filters", "avo-advanced"]

        # gems that will be encrypted using the holder gem's key and loaders
        GEMS_TO_ENCRYPT = ["avo-dashboards", "avo-menu", "avo-pro", "avo-dynamic_filters", "avo-advanced"]

        desc "Release #{GEMS.join(", ")}"

        argument :level,
          desc: "major|minor|patch|pre",
          default: "minor",
          required: false
        option :skip_bump,
          aliases: ["-sb"],
          type: :boolean,
          desc: "Skip bumping the version.",
          default: false,
          required: false
        option :skip_unstashed_changes,
          aliases: ["-suc"],
          type: :boolean,
          desc: "Skip checking for unstashed changes.",
          default: false,
          required: false

        def call(level:, skip_bump:, skip_unstashed_changes:, **)
          time_start = Time.now
          # Detect unstashed changes and show them to the user
          unless skip_unstashed_changes
            GEMS.each do |gem|
              Dir.chdir(gem) do
                files = `git status --porcelain`.split("\n")
                if files.any?
                  say "You have unstashed changes in #{gem}:"
                  files.each do |file|
                    say file
                  end

                  say "Would you like to continue anyway? (y/n)"
                  answer = STDIN.gets.chomp
                  if answer != "y"
                    exit
                  end
                end
              end
            end
          end

          time_prepare_release_start = Time.now
          parallelize(GEMS, label: "Prepare release") do |gem|
            Dir.chdir(gem) { PrepareRelease.new.call level:, skip_bump: }
          end
          time_prepare_release_end = Time.now

          time_encrypt_gems_start = Time.now
          parallelize(GEMS_TO_ENCRYPT, label: "Encrypt") do |gem|
            Dir.chdir(gem) { Encrypt.new.call }
          end
          time_encrypt_gems_end = Time.now

          time_build_gems_start = Time.now
          parallelize(GEMS, label: "Build") do |gem|
            Dir.chdir(gem) { BuildGem.new.call }
          end
          time_build_gems_end = Time.now

          time_appraisal_start = Time.now
          parallelize(GEMS_TO_ENCRYPT, label: "Appraisal") do |gem|
            Dir.chdir(gem) { Appraise.new.call }
          end
          time_appraisal_end = Time.now

          time_cleanup_encrypted_start = Time.now
          parallelize(GEMS_TO_ENCRYPT, label: "Cleanup encrypted files") do |gem|
            Dir.chdir(gem) { CleanupEncrypted.new.call }
          end
          time_cleanup_encrypted_end = Time.now

          # say "Gems are encrypted and ready to be pushed, do you want to continue? (y/n)"
          # answer = STDIN.gets.chomp
          # if answer != "y"
          #   exit
          # end

          # Exclude avo because it's already pushed to rubygems.org
          # Only after public release of avo, for now we push it to github packages
          time_push_start = Time.now
          parallelize(GEMS, label: "Push") do |gem|
            Dir.chdir(gem) { Push.new.call only_push_to_github: true }
          end
          time_push_end = Time.now

          time_commit_start = Time.now
          parallelize(GEMS, label: "Commit") do |gem|
            Dir.chdir(gem) do
              say "==============================================="
              say "Commiting #{gem} to GitHub"
              say "==============================================="
              # Don't tag for now
              Commit.new.call gem: gem, tag: false
            end
          end
          time_commit_end = Time.now
          time_end = Time.now

          say "Total time taken: #{time_end - time_start} seconds"
          say "Time taken to prepare release: #{time_prepare_release_end - time_prepare_release_start} seconds"
          say "Time taken to encrypt all gems: #{time_encrypt_gems_end - time_encrypt_gems_start} seconds"
          say "Time taken to build gems: #{time_build_gems_end - time_build_gems_start} seconds"
          say "Time taken to appraisal: #{time_appraisal_end - time_appraisal_start} seconds"
          say "Time taken to cleanup encrypted files: #{time_cleanup_encrypted_end - time_cleanup_encrypted_start} seconds"
          say "Time taken to push gems: #{time_push_end - time_push_start} seconds"
          say "Time taken to commit gems: #{time_commit_end - time_commit_start} seconds"
        end
      end

      class Run < BaseCommand
        desc "Run a command"

        argument :command, default: "bundle install", desc: "The command you'd like to run"
        option :gem, aliases: ["-g"], required: false, desc: "The gem where you want to run the command on"
        option :all, default: false, type: :boolean, desc: "Run the command in all gems."

        def call(command: "bundle install", gem: nil, all: false, **)
          if gem
            say "Running '#{command}' in #{gem}"

            cmd.run(command)
          elsif all
            say gems.inspect
            gems.each do |gem, path|
              say path
              say "Running `#{command}` in #{path}"

              cmd.run(command, chdir: path.to_s)
            end
          else
            say "You must run this command with `--gem GEM_NAME` or `--all`"
          end
        end
      end

      class Setup < BaseCommand
        desc "Setup all the repos"

        def call(gem: nil, **)
          say "Starting the setup process."

          # Make sure we are running the command in the `gems` directory
          current_dir = Dir.pwd.split("/").last
          cwd = if current_dir == "support"
            "#{Dir.pwd}/.."
          else
            Dir.pwd
          end
          repos = gems.keys + %w[testy]

          Dir.chdir(cwd) do
            repos.each do |repo|
              if Dir.exist?(repo)
                say "Skipping clone for #{repo}"
              else
                say "Cloning #{repo}"

                puts `git clone git@github.com:avo-hq/#{repo}.git`
              end
            end

            repos.each do |repo|
              Dir.chdir(repo) do
                unless Dir.glob("*.gemspec").empty?
                  say "Running `bundle install` in #{repo}"
                  puts `bundle install`
                end

                if File.exist?("yarn.lock")
                  say "Running `yarn install` in #{repo}"
                  puts `yarn install`
                end
              end
            end
          end
        end
      end

      chdir = lambda do |args|
        if args[:gem]
          gem_name = (args[:gem] == "avo") ? args[:gem] : "avo-#{args[:gem].gsub("avo-", "")}"

          if Dir.exist?(gem_name)
            Dir.chdir(gem_name)
            say "Running command in #{gem_name}"
            # update the args to have the full gem name
            # EX: if the user passes "--gem dashboards", the gem is transformed to "avo-dashboards"
            args[:gem] = gem_name
          elsif Pathname.new("../#{gem_name}").directory?
            # If the user runs the command from the support or testy dirs, we should be able to continue to run the command
            args[:gem] = gem_name
            Dir.chdir(Pathname.new("../#{gem_name}"))
            say "Running command in #{Pathname.new("../#{gem_name}").realpath}"
          else
            say "Failed to find that gem."
            exit 0
          end
        end
      end

      check_for_gem = lambda do |args|
        if Dir.glob("*.gemspec").empty?
          say "Failed to find a gem in the current directory. Stopping execution."
          exit 0
        end
      end

      register "version", Version, aliases: ["v", "-v", "--version"]

      common_comands = ["bump", "build", "push", "commit", "release", "prepare_release", "encrypt", "build_gem", "appraise", "cleanup_encrypted"]

      register "run", Run
      register "bump", Bump
      register "build", Build
      register "push", Push
      register "commit", Commit
      register "release", Release
      register "prepare_release", PrepareRelease
      register "encrypt", Encrypt
      register "build_gem", BuildGem
      register "appraise", Appraise
      register "cleanup_encrypted", CleanupEncrypted
      register "release_all", ReleaseAll
      register "setup", Setup

      before "run", &chdir

      common_comands.each do |c|
        before c, &chdir
        before c, &check_for_gem
      end
    end
  end
end

Dry::CLI.new(Buddy::CLI::Commands).call
