#!/usr/bin/env ruby

require "bundler/inline"

gemfile do 
  source "https://rubygems.org"

  ### bud gems
  gem "awesome_print"
  gem "dry-initializer"
  gem "activesupport", "> 7.0.4", "< 7.1.0"
  gem "dry-cli"
  gem "paint"
  gem "tty-command"
  gem "bump"
  gem "gem-release"
  gem "bigdecimal"
  gem "mutex_m"
  gem "logger"
  gem "benchmark"
end


# require "dry/cli"
require "active_support/all"
# require "yaml"
# require "json"
# require "tty-command"
# require "fileutils"
# require "bump"
# require "pathname"
# require "rubygems"
require_relative "support"

DOCKER_PROGRESS = "auto" # auto|plain

GEMS_TO_ENCRYPT = [
  "avo-dashboards",
  "avo-menu",
  "avo-pro",
  "avo-dynamic_filters",
  "avo-advanced",
  "avo-licensing"
].freeze

module Buddy
  VERSION = "0.0.1"

  module CLI
    module Commands
      extend Dry::CLI::Registry

      class BaseCommand < Dry::CLI::Command
        def run(command, cmd_options: {}, **options)
          Bundler.with_unbundled_env do
            result = cmd(**cmd_options).run(command, chdir: @path, **options)
            halt if result.failed?
            result
          end
        rescue TTY::Command::ExitError => e
          halt
        end

        def halt(message: nil)
          message ||= "#{self.class} failed."
          yell message
          exit 1
        end

        def benchmark_phase(label)
          start_time = Time.now
          yield
          Time.now - start_time
        end

        def print_timing_table(timings, total_time)
          puts "\n"
          puts "┌─────────────────────┬────────────┬─────────────┐"
          puts "│ Phase               │ Seconds    │ Minutes     │"
          puts "├─────────────────────┼────────────┼─────────────┤"
          timings.each do |label, time|
            secs = time.round(2).to_s.ljust(10)
            mins = (time / 60).round(2).to_s.ljust(11)
            puts "│ #{label.ljust(19)} │ #{secs} │ #{mins} │"
          end
          puts "├─────────────────────┼────────────┼─────────────┤"
          secs = total_time.round(2).to_s.ljust(10)
          mins = (total_time / 60).round(2).to_s.ljust(11)
          puts "│ #{"Total".ljust(19)} │ #{secs} │ #{mins} │"
          puts "└─────────────────────┴────────────┴─────────────┘"
        end

        def parallelize(items, label: nil, &block)
          start_time = Time.now

          pids_to_items = {}
          items.each do |item|
            pid = Process.fork do
              begin
                block.call(item)
              rescue SystemExit
                raise
              rescue Exception => e
                warn e.message
                exit 1
              end
            end
            pids_to_items[pid] = item
          end

          failures = []
          pids_to_items.each do |pid, item|
            _wpid, status = Process.wait2(pid)
            failures << item unless status.success?
          end

          halt(message: "#{label || 'Parallel step'} failed for: #{failures.join(', ')}") if failures.any?

          Time.now - start_time
        end
      end

      class Version < BaseCommand
        desc "Print version"

        def call(*)
          puts VERSION
        end
      end

      class Bump < BaseCommand
        desc "Bump gem"

        argument :level, desc: "major|minor|patch|pre"
        option :gem, aliases: ["-g"], required: false, desc: "The gem where you want to run the command on"

        def call(level: "minor", gem: nil, **)
          version, _ = ::Bump::Bump.run(level, commit: false, bundle: false, tag: false)

          say bump_message(version)
        end
      end

      class Encrypt < BaseCommand
        desc "Encrypt gem files using holder's key and loaders"

        option :gem, aliases: ["-g"], required: false, desc: "The gem where you want to run the command on"
        def call(gem: nil, **)
          return unless gem.in?(GEMS_TO_ENCRYPT)
          return if version.start_with?("1.") || version.start_with?("2.") || version.start_with?("3.")

          run("evocation encrypt gem #{gemspec_name}.gemspec --key_path ../avo-licensing/.evocation/symmetric_key.bin --loader_gem avo-licensing")
        end
      end

      class CleanupEncrypted < BaseCommand
        desc "Remove .enc files and restore originals"

        option :gem, aliases: ["-g"], required: false, desc: "The gem where you want to run the command on"

        def call(gem: nil, **)
          return unless gem.in?(GEMS_TO_ENCRYPT)
          return if version.start_with?("1.") || version.start_with?("2.") || version.start_with?("3.")

          run <<~BASH
            for enc_file in $(find . -name "*.enc"); do
              rm -f $enc_file
              git checkout ${enc_file%.enc}.rb
            done
          BASH
        end
      end
      class Appraise < BaseCommand
        desc "Run appraisal"

        def call(**)
          run("bundle exec appraisal")
        end
      end

      class Build < BaseCommand
        desc "Build the gem"

        option :gem, aliases: ["-g"], required: false, desc: "The gem where you want to run the command on"
        option :all, type: :boolean, default: false, desc: "Build the gem in all gems."

        def call(gem: nil, all: false, **)
          run("rm -rf ./pkg/*")

          run("bundle exec rails build && mv ./pkg/*.gem #{destination_path}")
        end
      end

      class Push < BaseCommand
        desc "Push the gem"

        option :gem, aliases: ["-g"], required: false, desc: "The gem where you want to run the command on"

        def call(gem: nil, **)
          if gemspec_name == "avo" && !version.start_with?("4.")
            `gem push --host https://rubygems.org/ ./pkg/#{gemspec_name}.gem`
          else
            `gem push --key github --host https://rubygems.pkg.github.com/avo-hq ./pkg/#{gemspec_name}.gem`
          end
        end
      end

      class Commit < BaseCommand
        desc "Commit the version change"
        option :gem, aliases: ["-g"], required: false, desc: "The gem where you want to run the command on"
        option :tag, type: :boolean, default: true, desc: "Tag the version."
        option :origin, default: "main", desc: "The origin branch to push to."

        def call(gem: nil, tag: true, origin: "main", **)
          if gem == "avo"
            `git add ./lib/avo/version.rb`
          else
            `git add ./lib/avo/#{name}/version.rb`
          end
          `git add ./Gemfile.lock`

          `git add gemfiles/`

          tag_name = "v#{version}"

          `git commit -m "#{bump_message(version)}"`
          if tag
            `git tag -a -m "#{bump_message(version)}" #{tag_name}`
          end

          `git push origin #{origin} --follow-tags`
        end
      end

      class Release < BaseCommand
        desc "Release the gem"

        # all the gems that will be released
        GEMS = ["avo", "avo-dashboards", "avo-menu", "avo-pro", "avo-dynamic_filters", "avo-advanced"]

        option :gem, aliases: ["-g"], required: false, desc: "The gem where you want to run the command on"
        option :skip_bump, type: :boolean, aliases: ["-sb"], required: false, desc: "Skip bumping the version."
        option :all, type: :boolean, default: false, desc: "Release all gems."
        argument :level, desc: "major|minor|patch|pre"

        def call(gem: nil, skip_bump: false, level: "patch", all: false, **)
          if all
            say "Do you want to release avo 3 or avo 4? (3/4)"
            major_version = STDIN.gets.chomp
            if major_version == "4"
              branch = "4-dev"
            else
              branch = "main"
            end
  
            # Detect unstashed changes and show them to the user
            GEMS.each do |gem|
              chdir_to_gem(gem) do
                if `git branch --show-current`.chomp != branch
                  say "You are releasing #{gem} #{major_version}.x but you are not on the #{branch} branch. Please switch to the #{branch} branch and try again."
                  exit
                end
  
                files = `git status --porcelain`.split("\n")
                if files.any?
                  say "You have unstashed changes in #{gem}:"
                  files.each do |file|
                    say file
                  end
  
                  say "Would you like to continue anyway? (y/n)"
                  answer = STDIN.gets.chomp
                  if answer != "y"
                    exit
                  end
                end
              end
            end
  
            time_start = Time.now
  
            # Phase 1: Bump all versions
            time_bump = if skip_bump
              0
            else
              say "===================="
              say "= Bumping versions ="
              say "===================="
              parallelize(GEMS, label: "Bump versions") do |gem|
                run("bud bump #{level} --gem #{gem}", cmd_options: { printer: :quiet })
              end
            end

            # Phase 2: Run bundle install in all gems to update versions and inter-dependencies
            say "=================="
            say "= Bundling gems ="
            say "=================="
            time_bundle = parallelize(GEMS, label: "Bundle install") do |gem|
              run("bud bundle --gem #{gem}", cmd_options: { printer: :quiet })
            end

            # Phase 3: Build assets
            say "===================="
            say "= Building assets ="
            say "===================="
            time_build_assets = parallelize(GEMS, label: "Build assets") do |gem|
              run("bud build_assets --gem #{gem}", cmd_options: { printer: :quiet })
            end

            # Phase 4: Encrypt gems
            say "===================="
            say "= Encrypting gems ="
            say "===================="
            time_encrypt = parallelize(GEMS_TO_ENCRYPT, label: "Encrypt gems") do |gem|
              run("bud encrypt --gem #{gem}", cmd_options: { printer: :quiet })
            end
  
            # Phase 5: Build gems
            say "===================="
            say "= Building gems   ="
            say "===================="
            time_build_gems = parallelize(GEMS, label: "Build gems") do |gem|
              run("bud build --gem #{gem}", cmd_options: { printer: :quiet })
            end

            # Phase 6: Cleanup encrypted files
            say "==========================="
            say "= Cleanup encrypted files ="
            say "==========================="
            time_cleanup_encrypted = parallelize(GEMS_TO_ENCRYPT, label: "Cleanup encrypted files") do |gem|
              run("bud cleanup_encrypted --gem #{gem}", cmd_options: { printer: :quiet })
            end

            # Phase 7: Push gems
            say "================"
            say "= Pushing gems ="
            say "================"
            time_push = parallelize(GEMS, label: "Push") do |gem|
              run("bud push --gem #{gem}")
            end
  
            # Phase 8: Commit gems
            say "==================="
            say "= Committing gems ="
            say "==================="
            time_commit = parallelize(GEMS, label: "Commit") do |gem|
              run("bud commit --gem #{gem} #{"--no-tag" if major_version == '4'} --origin #{branch}")
            end
  
            time_end = Time.now
            time_total = time_end - time_start
  
            # Build timing data
            timings = [
              ["Bump versions", time_bump],
              ["Bundle install", time_bundle],
              ["Build assets", time_build_assets],
              ["Encrypt gems", time_encrypt],
              ["Build gems", time_build_gems],
              ["Cleanup encrypted", time_cleanup_encrypted],
              ["Push gems", time_push],
              ["Commit gems", time_commit]
            ]

            print_timing_table(timings, time_total)
          else
            gem = gem || gemspec_name
            major_version = version.split(".").first

            if major_version == "4"
              branch = "4-dev"
            else
              branch = "main"
            end

            files = `git status --porcelain`.split("\n")

            if files.any?
              say "You have unstashed changes in #{gem}:"
              files.each do |file|
                say file
              end

              say "Would you like to continue anyway? (y/n)"
              answer = STDIN.gets.chomp
              if answer != "y"
                exit
              end
            end

            time_start = Time.now

            # Phase 1: Bump gem version
            time_bump = if skip_bump
              0
            else
              benchmark_phase("Bump version") do
                say "===================="
                say "= Bumping version ="
                say "===================="
                run("bud bump #{level} --gem #{gem}")
              end
            end

            # Phase 2: Bundle
            time_bundle = benchmark_phase("Bundle gem") do
              say "================"
              say "= Bundling gem ="
              say "================"
              run("bud bundle --gem #{gem}")
            end

            # Phase 3: Build assets
            time_build_assets = benchmark_phase("Build assets") do
              say "===================="
              say "= Building assets ="
              say "===================="
              run("bud build_assets --gem #{gem}")
            end

            # Phase 4: Encrypt gems
            time_encrypt = benchmark_phase("Encrypt gem") do
              say "===================="
              say "= Encrypting gems ="
              say "===================="
              run("bud encrypt --gem #{gem}")
            end

            # Phase 5: Build gems
            time_build = benchmark_phase("Build gem") do
              say "===================="
              say "= Building gems   ="
              say "===================="
              run("bud build --gem #{gem}")
            end

            # Phase 6: Cleanup encrypted files
            time_cleanup = benchmark_phase("Cleanup encrypted") do
              say "==========================="
              say "= Cleanup encrypted files ="
              say "==========================="
              run("bud cleanup_encrypted --gem #{gem}")
            end

            # Phase 7: Push gems
            time_push = benchmark_phase("Push gem") do
              say "================"
              say "= Pushing gems ="
              say "================"
              run("bud push --gem #{gem}")
            end

            # Phase 8: Commit gems
            time_commit = benchmark_phase("Commit gem") do
              say "==================="
              say "= Committing gems ="
              say "==================="
              run("bud commit --gem #{gem} #{"--no-tag" if major_version == '4'} --origin #{branch}")
            end

            time_total = Time.now - time_start

            # Build timing data
            timings = [
              ["Bump version", time_bump],
              ["Bundle gem", time_bundle],
              ["Build assets", time_build_assets],
              ["Encrypt gem", time_encrypt],
              ["Build gem", time_build],
              ["Cleanup encrypted", time_cleanup],
              ["Push gem", time_push],
              ["Commit gem", time_commit]
            ]

            print_timing_table(timings, time_total)
          end
        end
      end

      class BuildAssets < BaseCommand
        desc "Build assets and clean the pkg directory"

        option :gem, aliases: ["-g"], required: false, desc: "The gem where you want to build the assets on"

        def call(gem: nil, all: false, **)
          # 1. If exists, clean the app/assets/builds directory
          if Dir.exist?("app/assets/builds")
            run("rm -rf app/assets/builds/*")
            run("touch app/assets/builds/.keep")
          end

          # 2. If package.json exists, build the assets
          if File.exist?("package.json")
            # run("rm -rf node_modules")
            run("yarn --silent")

            # Check if prod:build script exists, otherwise fallback to build
            build_script = JSON.parse(File.read("package.json")).dig("scripts", "prod:build") ? "prod:build" : "build"
            run("yarn #{build_script}")

            # Avo needs to build the assets again because sym_link requires application.css to be present
            # This is a temporary solution until we have a better way to handle this
            if gem == "avo"
              run("rails avo:sym_link")

              if Dir.exist?("app/assets/builds")
                run("rm -rf app/assets/builds/*")
                run("touch app/assets/builds/.keep")
              end

              # run("rm -rf node_modules")
              run("yarn --silent")
              run("yarn #{build_script}")
            end
          end
        end
      end
      class Run < BaseCommand
        desc "Run a command"

        argument :command, default: "bundle install", desc: "The command you'd like to run"
        option :gem, aliases: ["-g"], required: false, desc: "The gem where you want to run the command on"
        option :all, default: false, type: :boolean, desc: "Run the command in all gems."

        def call(command: "bundle install", gem: nil, all: false, **)
          if gem
            say "Running '#{command}' in #{gem}"

            run(command)
          elsif all
            parallelize(gems.keys, label: "Running command in all gems") do |gem|
              chdir_to_gem(gem) {
                say "Running `#{command}` in #{gem}"
                run(command)
              }
            end
          else
            say "You must run this command with `--gem GEM_NAME` or `--all`"
          end
        end
      end

      class Bundle < BaseCommand
        desc "Run bundle install"

        option :gem, aliases: ["-g"], required: false, desc: "The gem where you want to run the command on"

        def call(gem: nil, all: false, **)
          run("bundle install --quiet")
          run("bundle exec appraisal")
        end
      end

      class Setup < BaseCommand
        desc "Setup all the repos"

        def call(gem: nil, **)
          say "Starting the setup process."

          # Make sure we are running the command in the `gems` directory
          current_dir = Dir.pwd.split("/").last
          cwd = if current_dir == "support"
            "#{Dir.pwd}/.."
          else
            Dir.pwd
          end
          repos = gems.keys + %w[testy]

          Dir.chdir(cwd) do
            repos.each do |repo|
              if Dir.exist?(repo)
                say "Skipping clone for #{repo}"
              else
                say "Cloning #{repo}"

                puts `git clone git@github.com:avo-hq/#{repo}.git`
              end
            end

            repos.each do |repo|
              Dir.chdir(repo) do
                unless Dir.glob("*.gemspec").empty?
                  say "Running `bundle install` in #{repo}"
                  puts `bundle install`
                end

                if File.exist?("yarn.lock")
                  say "Running `yarn install` in #{repo}"
                  puts `yarn install`
                end
              end
            end
          end
        end
      end

      chdir = lambda do |args|
        if args[:gem]
          gem_name = (args[:gem] == "avo") ? args[:gem] : "avo-#{args[:gem].gsub("avo-", "")}"

          begin
            chdir_to_gem(gem_name)
            args[:gem] = gem_name
          rescue => e
            say "Error: #{e.message}"
            say "Failed to find that gem."
            exit 0
          end
        end
      end

      check_for_gem = lambda do |args|
        return if args[:all]
        return if @path.present? && Dir.exist?(@path) && Dir.glob("#{@path}/*.gemspec").any?
        return if Dir.glob("*.gemspec").any?

        say "Failed to find a gem in the current directory. Stopping execution."
        exit 0
      end

      register "version", Version, aliases: ["v", "-v", "--version"]

      common_comands = ["build", "bundle", "bump", "push", "commit", "release", "build_assets", "encrypt", "cleanup_encrypted"]

      register "run", Run
      register "bundle", Bundle
      register "bump", Bump
      register "build", Build
      register "push", Push
      register "commit", Commit
      register "release", Release
      register "build_assets", BuildAssets
      register "setup", Setup
      register "encrypt", Encrypt
      register "cleanup_encrypted", CleanupEncrypted
      before "run", &chdir

      common_comands.each do |c|
        before c, &chdir
        before c, &check_for_gem
      end
    end
  end
end

Dry::CLI.new(Buddy::CLI::Commands).call
