#!/usr/bin/env ruby

# Use `bud`s Gemfile and bundler dependencies
root = File.expand_path(File.join(__dir__))
if File.file?(File.join(root, 'Gemfile.lock'))
  Dir.chdir(root) do
    require 'bundler/setup'
  rescue LoadError => e
    warn e.message
    warn "Run `gem install bundler` to install Bundler"
    exit(-1)
  end
end

require "dry/cli"
require "active_support/all"
require "yaml"
require "tty-command"
require "fileutils"
require "bump"
require "pathname"
require "rubygems"
require_relative "support"

DOCKER_PROGRESS = "auto" # auto|plain

module Buddy
  VERSION = "0.0.1"

  module CLI
    module Commands
      extend Dry::CLI::Registry

      class BaseCommand < Dry::CLI::Command
        def run(command)
          result = cmd.run(command)
          halt if result.failed?
          result
        rescue TTY::Command::ExitError => e
          halt
        end

        def halt(message: nil)
          message ||= "#{self.class} failed."
          yell message
          exit
        end
      end

      class Version < BaseCommand
        desc "Print version"

        def call(*)
          puts VERSION
        end
      end

      class Bump < BaseCommand
        desc "Bump gem"

        argument :level, desc: "major|minor|patch|pre"
        option :gem, aliases: ["-g"], required: false, desc: "The gem where you want to run the command on"

        def call(level: "minor", gem: nil, **)
          version, _ = ::Bump::Bump.run(level, commit: false, bundle: false, tag: false)

          run("bundle")

          say message(version)
        end
      end

      class Build < BaseCommand
        desc "Build the gem"

        option :gem, aliases: ["-g"], required: false, desc: "The gem where you want to run the command on"

        def call(gem: nil, forced_avo_version: nil, **)
          FileUtils.mkdir_p "pkg"

          avo_version = forced_avo_version || avo_gem_version

          say "avo version: #{avo_version}"

          remove_previous_gem

          # We prepare these files so the cache does not get busted once the version is incremented in Gemfile.lock
          add_v1_files

          # Build the base image
          run("docker build -t avo_base -f ./../support/docker/Dockerfile.base ./../avo --progress #{DOCKER_PROGRESS}")
          # Build the image with Avo included
          run("docker build -t avo_gems -f ./../support/docker/Dockerfile.gems ./.. --progress #{DOCKER_PROGRESS}")
          say "Base Docker image built"

          # For Avo we use a special Dockerfile and building from the root directory
          dockerfile = (name == "avo") ? "Dockerfile.avo" : "Dockerfile"
          build_path = (name == "avo") ? "../." : "."

          # Build the build image
          say "Building Docker image"
          run("docker build -t #{name} -f ./../support/docker/#{dockerfile} #{build_path} --progress #{DOCKER_PROGRESS} --build-arg NAME=#{name} --build-arg GEMSPEC_NAME=#{gemspec_name} --build-arg BUNDLER_TOKEN=#{bundler_token} --build-arg AVO_VERSION=#{avo_version}")
          say "Docker image built"

          src = "/#{name}/pkg/#{gemspec_name}-#{version}.gem"

          run "docker cp #{image_id}:#{src} #{destination_path}"
          say "Copied gem from docker image to #{destination_path}"

          run("bundle exec appraisal")
        end
      end

      class Push < BaseCommand
        desc "Push the gem"

        option :gem, aliases: ["-g"], required: false, desc: "The gem where you want to run the command on"

        def call(gem: nil, **)
          if gemspec_name == "avo"
            `gem push --host https://rubygems.org/ ./pkg/#{gemspec_name}.gem`
          else
            `gem push --key github --host https://rubygems.pkg.github.com/avo-hq ./pkg/#{gemspec_name}.gem`
          end
        end
      end

      class Commit < BaseCommand
        desc "Commit the version change"
        option :gem, aliases: ["-g"], required: false, desc: "The gem where you want to run the command on"

        def call(gem: nil, **)
          if name == "avo"
            `git add ./lib/avo/version.rb`
          else
            `git add ./lib/avo/#{name}/version.rb`
          end
          `git add ./Gemfile.lock`

          `git add gemfiles/`

          tag = "v#{version}"

          `git commit -m "#{message(version)}"`
          `git tag -a -m "#{message(version)}" #{tag}`

          `git push origin main --follow-tags`
        end
      end

      class Release < BaseCommand
        desc "Release the gem"

        option :gem, aliases: ["-g"], required: false, desc: "The gem where you want to run the command on"
        option :skip_bump, type: :boolean, aliases: ["-sb"], required: false, desc: "Skip bumping the version."
        argument :level, desc: "major|minor|patch|pre"

        def call(gem: nil, skip_bump: false, level: "patch", **)
          # 1. Bump gem version
          if skip_bump
            # Run bundle to increment the version number in Gemfile.lock
            run("bundle")
          else
            Bump.new.call level:
          end
          # 2. Build the gem
          Build.new.call
          # 3. Push to GitHub packages
          Push.new.call
          # 4. commit & upload tag to git
          #    GitHub action will generate the release with release notes
          Commit.new.call
        end
      end

      class ReleaseAll < BaseCommand
        # all the gems that will be released
        GEMS = ["avo", "avo-dashboards", "avo-menu", "avo-pro", "avo-dynamic_filters", "avo-advanced"]

        # gem that will be used to build the evocation loaders and will ship them
        # I chose avo-dashboards because it's the gem that is a dependency for all the other gems
        # We could use avo as well, maybe in the future we will use it
        LOADER_HOLDER = "avo-dashboards"
        # gems that will be encrypted using the holder gem's key and loaders
        GEMS_TO_ENCRYPT = ["avo-dashboards", "avo-menu", "avo-pro", "avo-dynamic_filters", "avo-advanced"]

        desc "Release #{GEMS.join(", ")}"

        argument :level,
          desc: "major|minor|patch|pre",
          default: "minor",
          required: false
        option :skip_bump,
          aliases: ["-sb"],
          type: :boolean,
          desc: "Skip bumping the version.",
          default: false,
          required: false
        option :skip_unstashed_changes,
          aliases: ["-suc"],
          type: :boolean,
          desc: "Skip checking for unstashed changes.",
          default: false,
          required: false

        def call(level:, skip_bump:, skip_unstashed_changes:, **)
          time_start = Time.now
          # Detect unstashed changes and show them to the user
          unless skip_unstashed_changes
            GEMS.each do |gem|
              Dir.chdir(gem) do
                files = `git status --porcelain`.split("\n")
                if files.any?
                  say "You have unstashed changes in #{gem}:"
                  files.each do |file|
                    say file
                  end

                  say "Would you like to continue anyway? (y/n)"
                  answer = STDIN.gets.chomp
                  if answer != "y"
                    exit
                  end
                end
              end
            end
          end

          GEMS.each do |gem|
            Dir.chdir(gem) do
              say "==============================================="
              say "PREPARE RELEASE & BUMP VERSION for #{gem}"
              say "==============================================="
              run("rm -rf ./tmp/*")
              run("rm -rf ./pkg/*")
              run("find .evocation -mindepth 1 ! -name 'config.yml' -exec rm -rf {} +")

              if Dir.exist?("app/assets/builds")
                run("rm -rf app/assets/builds/*")
                run("touch app/assets/builds/.keep")
              end

              if File.exist?("package.json")
                run("rm -rf node_modules")
                run("yarn")
                run("yarn build")

                # Avo needs to build the assets again because sym_link requires application.css to be present
                # This is a temporary solution until we have a better way to handle this
                if gem == "avo"
                  run("rails avo:sym_link")

                  if Dir.exist?("app/assets/builds")
                    run("rm -rf app/assets/builds/*")
                    run("touch app/assets/builds/.keep")
                  end

                  run("rm -rf node_modules")
                  run("yarn")
                  run("yarn build")
                end
              end
              unless skip_bump
                Bump.new.call level:
              end
            end
          end

          time_build_loaders_start = Time.now
          Dir.chdir(LOADER_HOLDER) do
            say "==============================================="
            say "BUILD EVOCATION LOADERS on #{LOADER_HOLDER}"
            say "==============================================="
            run("evocation key create")
            run("evocation loader generate")
            run("EVOCATION_DIR=$(realpath ../evocation) RCD_MOUNTDIR=$(pwd)/.. evocation loader cross_compile #{LOADER_HOLDER}.gemspec")
          end
          time_build_loaders_end = Time.now

          time_encrypt_gems_start = Time.now
          GEMS_TO_ENCRYPT.each do |gem|
            Dir.chdir(gem) do
              say "==================================================================="
              say "Encrypting #{gem} using #{LOADER_HOLDER}'s key and loaders"
              say "==================================================================="
              run("evocation encrypt gem #{gem}.gemspec --key_path ../#{LOADER_HOLDER}/.evocation/symmetric_key.bin --loader_gem #{LOADER_HOLDER}")
            end
          end

          time_encrypt_gems_end = Time.now

          time_build_gems_start = Time.now
          GEMS.each do |gem|
            Dir.chdir(gem) do
              say "==============================================="
              say "BUILD #{gem}"
              say "==============================================="
              run("bundle exec rails build")
            end
          end

          time_build_gems_end = Time.now

          GEMS_TO_ENCRYPT.each do |gem|
            Dir.chdir(gem) do
              say "==============================================="
              say "APPRAISAL for #{gem}"
              say "==============================================="
              run("bundle exec appraisal")

              say "==============================================="
              say "Removing encrypted files for #{gem}"
              say "==============================================="

              run <<~BASH
                for enc_file in $(find . -name "*.enc"); do
                  rm -f $enc_file
                  git checkout ${enc_file%.enc}.rb
                done
              BASH
            end
          end


          say "Gems are encrypted and ready to be pushed, do you want to continue? (y/n)"
          answer = STDIN.gets.chomp
          if answer != "y"
            exit
          end

          # Exclude avo because it's already pushed to rubygems.org
          # Only after public release of avo, for now we push it to github packages
          GEMS.each do |gem|
            Dir.chdir(gem) do
              say "==============================================="
              say "Pushing #{gem} to github packages"
              say "==============================================="
              `gem push --key github --host https://rubygems.pkg.github.com/avo-hq ./pkg/#{gem}-*.gem`
            end
          end

          GEMS.each do |gem|
            Dir.chdir(gem) do
              say "==============================================="
              say "Commiting #{gem} to GitHub"
              say "==============================================="
              Commit.new.call gem: gem
            end
          end

          time_end = Time.now

          say "Total time taken: #{time_end - time_start} seconds"
          say "Time taken to build loaders: #{time_build_loaders_end - time_build_loaders_start} seconds"
          say "Time taken to encrypt all gems: #{time_encrypt_gems_end - time_encrypt_gems_start} seconds"
          say "Time taken to build gems: #{time_build_gems_end - time_build_gems_start} seconds"
        end
      end

      class Run < BaseCommand
        desc "Run a command"

        argument :command, default: "bundle install", desc: "The command you'd like to run"
        option :gem, aliases: ["-g"], required: false, desc: "The gem where you want to run the command on"
        option :all, default: false, type: :boolean, desc: "Run the command in all gems."

        def call(command: "bundle install", gem: nil, all: false, **)
          if gem
            say "Running '#{command}' in #{gem}"

            cmd.run(command)
          elsif all
            say gems.inspect
            gems.each do |gem, path|
              say path
              say "Running `#{command}` in #{path}"

              cmd.run(command, chdir: path.to_s)
            end
          else
            say "You must run this command with `--gem GEM_NAME` or `--all`"
          end
        end
      end

      class Setup < BaseCommand
        desc "Setup all the repos"

        def call(gem: nil, **)
          say "Starting the setup process."

          # Make sure we are running the command in the `gems` directory
          current_dir = Dir.pwd.split("/").last
          cwd = if current_dir == "support"
            "#{Dir.pwd}/.."
          else
            Dir.pwd
          end
          repos = gems.keys + %w[testy]

          Dir.chdir(cwd) do
            repos.each do |repo|
              if Dir.exist?(repo)
                say "Skipping clone for #{repo}"
              else
                say "Cloning #{repo}"

                puts `git clone git@github.com:avo-hq/#{repo}.git`
              end
            end

            repos.each do |repo|
              Dir.chdir(repo) do
                unless Dir.glob("*.gemspec").empty?
                  say "Running `bundle install` in #{repo}"
                  puts `bundle install`
                end

                if File.exist?("yarn.lock")
                  say "Running `yarn install` in #{repo}"
                  puts `yarn install`
                end
              end
            end
          end
        end
      end

      chdir = lambda do |args|
        if args[:gem]
          gem_name = (args[:gem] == "avo") ? args[:gem] : "avo-#{args[:gem].gsub("avo-", "")}"

          if Dir.exist?(gem_name)
            Dir.chdir(gem_name)
            say "Running command in #{gem_name}"
            # update the args to have the full gem name
            # EX: if the user passes "--gem dashboards", the gem is transformed to "avo-dashboards"
            args[:gem] = gem_name
          elsif Pathname.new("../#{gem_name}").directory?
            # If the user runs the command from the support or testy dirs, we should be able to continue to run the command
            args[:gem] = gem_name
            Dir.chdir(Pathname.new("../#{gem_name}"))
            say "Running command in #{Pathname.new("../#{gem_name}").realpath}"
          else
            say "Failed to find that gem."
            exit 0
          end
        end
      end

      check_for_gem = lambda do |args|
        if Dir.glob("*.gemspec").empty?
          say "Failed to find a gem in the current directory. Stopping execution."
          exit 0
        end
      end

      register "version", Version, aliases: ["v", "-v", "--version"]

      common_comands = ["bump", "build", "push", "commit", "release"]

      register "run", Run
      register "bump", Bump
      register "build", Build
      register "push", Push
      register "commit", Commit
      register "release", Release
      register "release_all", ReleaseAll
      register "setup", Setup

      before "run", &chdir

      common_comands.each do |c|
        before c, &chdir
        before c, &check_for_gem
      end
    end
  end
end

Dry::CLI.new(Buddy::CLI::Commands).call
